// === GET ELEMENTS ===
const board1 = document.getElementById("board1");
const board2 = document.getElementById("board2");
const resetButton = document.getElementById("reset-game");
const turnInfo = document.getElementById("turn-info");
const winnerInfo = document.getElementById("winner-info");

// ====== GAME STATE =======
let socket = null;
let roomId = null;
let playerNumber = null;   // 1 or 2
let currentPlayerTurn = null;
let gameStarted = false;
let gameOver = false;

let player1Board = [];
let player2Board = [];
let player1StruckLines = new Set();
let player2StruckLines = new Set();

// ====== UTILITY FUNCTIONS ======

// Generate unique random board of 25 numbers from 1-25
function generateBoard() {
  const numbers = [];
  while (numbers.length < 25) {
    const n = Math.floor(Math.random() * 25) + 1;
    if (!numbers.includes(n)) numbers.push(n);
  }
  return numbers;
}

// Create board UI and add click handlers
function createBoard(boardElement, boardArray, player) {
  boardElement.innerHTML = "";
  for (let i = 0; i < 25; i++) {
    const cell = document.createElement("div");
    cell.textContent = boardArray[i];
    cell.id = `${player === 1 ? "p1" : "p2"}-cell-${boardArray[i]}`;
    cell.classList.add("bingo-cell");
    cell.addEventListener("click", () => {
      if (gameOver || player !== playerNumber) return;
      if (!isMyTurn()) return;
      // Only allow clicks on non-struck cells
      if (!cell.classList.contains("strike")) {
        sendPlayerMove(boardArray[i]);
      }
    });
    boardElement.appendChild(cell);
  }
}

// Mark cell as struck on board; update both player's boards accordingly
function strikeNumber(cell, number, player) {
  if (cell.classList.contains("strike") || gameOver) return;
  cell.classList.add("strike");

  // Strike same number on opponent's board
  const opponentBoard = player === 1 ? board2 : board1;
  Array.from(opponentBoard.querySelectorAll("div")).forEach(c => {
    if (parseInt(c.textContent) === number && !c.classList.contains("strike")) {
      c.classList.add("strike");
    }
  });

  turnInfo.textContent = `Player ${player} chose number ${number}`;

  // Check bingo for both players
  checkForBingo(player);
  checkForBingo(player === 1 ? 2 : 1);

  if (!gameOver) {
    // Wait for server to update turns in multiplayer
    if (playerNumber) disableAllBoards(); // Disable input until next turn
  }
}

// Check if player has achieved bingo with 5 or more struck lines
function checkForBingo(player) {
  const boardEl = player === 1 ? board1 : board2;
  const struckLinesSet = player === 1 ? player1StruckLines : player2StruckLines;

  const cells = boardEl.querySelectorAll("div");
  const winningLines = [
    [0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24],
    [0,5,10,15,20],[1,6,11,16,21],[2,7,12,17,22],[3,8,13,18,23],[4,9,14,19,24],
    [0,6,12,18,24],[4,8,12,16,20]
  ];

  for (let i = 0; i < winningLines.length; i++) {
    const line = winningLines[i];
    if (line.every(idx => cells[idx].classList.contains("strike"))) {
      if (!struckLinesSet.has(i)) {
        struckLinesSet.add(i);
        line.forEach(idx => (cells[idx].style.backgroundColor = "#66ff66"));
      }
    }
  }

  if (struckLinesSet.size >= 5 && !gameOver) {
    winnerInfo.textContent = `ðŸŽ‰ Player ${player} wins with ${struckLinesSet.size} lines!`;
    gameOver = true;
    disableAllBoards();

    if (socket && roomId && playerNumber) {
      socket.emit("gameOver", { roomId, playerNumber: player });
    }
  }
}

// Disable all boards (used when waiting for opponent turn)
function disableAllBoards() {
  disableBoard(board1);
  disableBoard(board2);
}

function disableBoard(boardEl) {
  Array.from(boardEl.querySelectorAll("div")).forEach(cell => {
    cell.style.pointerEvents = "none";
  });
}

function enableBoard(boardEl) {
  Array.from(boardEl.querySelectorAll("div")).forEach(cell => {
    if (!cell.classList.contains("strike")) {
      cell.style.pointerEvents = "auto";
    }
  });
}

// Show/hide board visibility based on current player turn and this client player number
function updateBoardVisibility() {
  if (!gameStarted) return;

  if (currentPlayerTurn === playerNumber) {
    // It's this player's turn, show their board
    if (playerNumber === 1) {
      board1.parentElement.classList.remove("hidden-board");
      board2.parentElement.classList.add("hidden-board");
      enableBoard(board1);
      disableBoard(board2);
    } else {
      board2.parentElement.classList.remove("hidden-board");
      board1.parentElement.classList.add("hidden-board");
      enableBoard(board2);
      disableBoard(board1);
    }
  } else {
    // Opponent's turn, show opponent's board but disable clicking
    if (playerNumber === 1) {
      board2.parentElement.classList.remove("hidden-board");
      board1.parentElement.classList.add("hidden-board");
      disableBoard(board2);
      disableBoard(board1);
    } else {
      board1.parentElement.classList.remove("hidden-board");
      board2.parentElement.classList.add("hidden-board");
      disableBoard(board1);
      disableBoard(board2);
    }
  }
}

// Check if it's this client's turn
function isMyTurn() {
  return gameStarted && playerNumber === currentPlayerTurn && !gameOver;
}

// Reset game state for a new game or on reset
function resetGame() {
  gameStarted = false;
  gameOver = false;
  playerNumber = null;
  currentPlayerTurn = null;
  roomId = null;

  player1StruckLines.clear();
  player2StruckLines.clear();

  winnerInfo.textContent = "";
  turnInfo.textContent = "";
  document.getElementById("current-number").textContent = "";

  board1.innerHTML = "";
  board2.innerHTML = "";
  board1.parentElement.classList.add("hidden-board");
  board2.parentElement.classList.add("hidden-board");

  if (socket) {
    socket.disconnect();
    socket = null;
  }
}

// === SOCKET.IO CONNECTION & EVENT HANDLERS ===

function initSocketConnection() {
  socket = io("http://localhost:3000"); // Change to your server URL if needed

  socket.on("connect", () => {
    console.log("Connected to server", socket.id);
  });

  socket.on("connect_error", (err) => {
    console.error("Connection error:", err);
    turnInfo.textContent = "Connection error - unable to connect to server.";
  });

  socket.on("disconnect", (reason) => {
    console.log("Disconnected from server:", reason);
    if (!gameOver) {
      turnInfo.textContent = "Disconnected from server.";
      disableAllBoards();
    }
  });

  socket.on("waiting", (msg) => {
    turnInfo.textContent = msg; // e.g., "Waiting for opponent..."
  });

  socket.on("gameStart", (data) => {
    console.log("Game started:", data);
    roomId = data.roomId;
    playerNumber = data.playerNumber;
    currentPlayerTurn = data.gameState.currentPlayer;
    gameStarted = true;
    gameOver = false;
    winnerInfo.textContent = "";
    turnInfo.textContent = "Game started! Waiting for toss result...";

    // Generate boards locally
    player1Board = generateBoard();
    player2Board = generateBoard();

    createBoard(board1, player1Board, 1);
    createBoard(board2, player2Board, 2);
    updateBoardVisibility();
  });

  socket.on("tossResult", (data) => {
    turnInfo.textContent = `Player ${data.winner} won the toss and starts first!`;
    currentPlayerTurn = data.winner;
    updateBoardVisibility();
  });

  socket.on("turnUpdate", (data) => {
    currentPlayerTurn = data.currentPlayer;
    turnInfo.textContent = `Player ${currentPlayerTurn}'s turn`;
    updateBoardVisibility();
  });

  socket.on("opponentMove", (moveData) => {
    console.log("Opponent move:", moveData);
    applyOpponentMove(moveData);
  });

  socket.on("opponentLeft", () => {
    winnerInfo.textContent = "Opponent disconnected. You win!";
    gameOver = true;
    disableAllBoards();
  });
}

// Apply opponent's move visually
function applyOpponentMove(moveData) {
  const opponentPlayer = playerNumber === 1 ? 2 : 1;
  const boardEl = opponentPlayer === 1 ? board1 : board2;

  // Find cell by number and mark it struck
  const cell = Array.from(boardEl.querySelectorAll("div"))
    .find(c => parseInt(c.textContent) === moveData.number && !c.classList.contains("strike"));
  if (cell) {
    strikeNumber(cell, moveData.number, opponentPlayer);
  }
}

// Send player's move to server
function sendPlayerMove(number) {
  if (!socket || !roomId || !playerNumber || gameOver) return;

  socket.emit("playerMove", {
    roomId,
    playerNumber,
    moveData: { number }
  });

  // Optimistically mark move locally on player's own board
  const boardEl = playerNumber === 1 ? board1 : board2;
  const cell = Array.from(boardEl.querySelectorAll("div"))
    .find(c => parseInt(c.textContent) === number && !c.classList.contains("strike"));
  if (cell) {
    strikeNumber(cell, number, playerNumber);
  }

  disableAllBoards(); // Disable input until next turn
}

// === EVENT LISTENERS ===

// Example: Handle reset button
resetButton.addEventListener("click", () => {
  resetGame();
  turnInfo.textContent = "Game reset. You can select mode again.";
});

// Example starting multiplayer connection somewhere in your code:

// You might have a function or button that triggers multiplayer mode:
// For example:

function startMultiplayerMode() {
  resetGame();
  initSocketConnection();
  turnInfo.textContent = "Connecting to multiplayer server...";
}

// You can call `startMultiplayerMode()` when the multiplayer button is clicked in your UI.

